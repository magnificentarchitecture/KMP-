# 学习KMP算法
在整个算法中最重要的就是对于next数组的求解
而每一个next数组的值是公共前后缀的个数+1
但是如何理解next数组实现方式呢？
包括两个方面：

1. 假如`T[i] == T[j]`
```
if (i == -1 || T[i] == T[j])
{
	j++;
	i++;
	next[j] = i + 1;
}

```

本次循环与前一次循环的差别是多出了第j个字符，而之前的0至i-1和j-1即前面的i个字符已经是重复的。我们则需要判断第i和第j的字符是否相等，若相等则第j+1的字符前面的公共前后缀的个数是i+1个。因此，`i++; j++;`更新了一次

那么可以断定此时`next[j] == i（公共前后缀个数） + 1`

2. 假如`T[i] != T[j]`

   ```
   i = next[i] - 1;
   ```

   则需要将i进行退回

   假如我们求第17个字符的next值

   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17

   i=8，j=16，也就是说i在前面的循换顺利加加到8那么前7个与第9到第15个是重复的。若此时第16个与第8个若不相等而next数组中第八个的数是4，则可以发现567与123是重复的而1234567与9 10 11 12 13 14 15是重复的，那么此时567与13 14 15是重复的如果第16个与第4个是重复的则，17前面的公共前后缀数是4（即存在next数值为5的可能性）。假若不成立则i 继续向前退知道退到第一个数，若还不相等则17处的next值为1.

   当然我再写这些的时候与书上的不同之处在于字符串都是从0开始的而next保存的是第几个数，因此再减去一个1。

   ***能不能让next数组的值都减上一个1来做，这是不是与起点为0的字符串更适配呢？***

   

   

